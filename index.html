<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=generator content="Hugo 0.82.1"><title>Boomerang</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/pure-min.css><!--[if lte IE 8]><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-old-ie-min.css><![endif]--><!--[if gt IE 8]><!--><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-min.css><!--<![endif]--><!--[if lte IE 8]><link rel=stylesheet href=/css/side-menu-old-ie.css><![endif]--><!--[if gt IE 8]><!--><link rel=stylesheet href=/css/side-menu.css><!--<![endif]--><link rel=stylesheet href=/css/blackburn.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css><link rel=preconnect href=https://fonts.gstatic.com><link href="https://fonts.googleapis.com/css2?family=Raleway&display=swap" rel=stylesheet type=text/css><script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><link rel=alternate type=application/rss+xml title=Boomerang href=/index.xml><link rel=stylesheet href=//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/styles/Googlecode.min.css><script async src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/highlight.min.js></script><script>hljs.initHighlightingOnLoad()</script><link rel="shortcut icon" href=https://ajtl.github.ioimg/favicon.ico type=image/x-icon></head><body><div id=layout><a href=#menu id=menuLink class=menu-link><span></span></a><div id=menu><a class="pure-menu-heading brand" href=/>Boomerang</a><div class=pure-menu><ul class=pure-menu-list><li class=pure-menu-item><a class=pure-menu-link href=/><i class="fa fa-home fa-fw"></i>Home</a></li><li class=pure-menu-item><a class=pure-menu-link href=/post/><i class="fa fa-list fa-fw"></i>Posts</a></li><li class=pure-menu-item><a class=pure-menu-link href=/tags/><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class=pure-menu-item><a class=pure-menu-link href=/topics/><i class="fa fa-folder fa-fw"></i>Topics</a></li><li class=pure-menu-item><a class=pure-menu-link href=/about/><i class="fa fa-user fa-fw"></i>About</a></li><li class=pure-menu-item><a class=pure-menu-link href=/contact/><i class="fa fa-phone fa-fw"></i>Contact</a></li></ul></div><div class="pure-menu social"><ul class=pure-menu-list><li class=pure-menu-item><a class=pure-menu-link href=/index.xml><i class="fas fa-rss fa-fw"></i>RSS</a></li><li class=pure-menu-item><a class=pure-menu-link href=https://github.com/ajtl rel=me target=_blank><i class="fab fa-github-square fa-fw"></i>GitHub</a></li></ul></div><div><div class=small-print><small>&copy; 2019-2021. All rights reserved.</small></div><div class=small-print><small>Built with&nbsp;<a href=https://gohugo.io/ target=_blank>Hugo</a></small>
<small>Theme&nbsp;<a href=https://github.com/yoshiharuyamashita/blackburn target=_blank>Blackburn</a></small></div></div></div><div id=main><div class=header><h1>Boomerang</h1><h2>AJTL</h2></div><div class=content><article><header><h2><a href=https://ajtl.github.io/post/git_commit_manager/>Git Commit Message 规范设置</a></h2><div class=post-meta><div><i class="fa fa-calendar fa-fw"></i>
<time>17 Mar 2021, 16:13</time></div><div><i class="fa fa-folder fa-fw"></i>
<a class=post-taxonomy-topic href=https://ajtl.github.iotopics/git>Git</a></div><div><i class="fa fa-tags fa-fw"></i>
<a class=post-taxonomy-tag href=https://ajtl.github.iotags/git>Git</a></div></div></header><p>Chapter 1 简介 规范的进行 Git 提交有助于团队的开发管理。
符合规范的提交内容也能通过自动化脚本自动生成 changlog。
Chapter 2 准备工作 安装 Git 安装 Node.Js1 Chapter 3 提交格式 每一个提交都由header(标题)、body(内容)和footer(页脚)组成。其中header还包括了 type 、scope 和 subject，如下图所示：
&lt;type>(&lt;scope>): &lt;subject> &lt;BLANK-LINE> &lt;body> &lt;BLANK-LINE> &lt;footer> 标题部分: type、scope、subject type 必需 type 表示提交类别，比如是修复一个 bug 还是增加一个新的 feature。
feat 添加新特性 fix 修复漏洞 docs 仅仅修改了文档，比如 README, CHANGELOG, CONTRIBUTE 等等 style 仅仅修改了空格、格式缩进、逗号等等，不改变代码逻辑 refactor 代码重构，没有加新功能或者修复漏洞 perf 优化相关，比如提升性能、体验 test 增加测试用例，包括单元测试、集成测试等 chore 改变构建流程、或者增加依赖库、工具等 revert 回滚到之前某一版本 scope 可选 scope 表示修改范围，建议填写影响的功能模块。</p><footer><a href=/post/git_commit_manager/>Read more<i class="fa fa-angle-double-right fa-fw"></i></a></footer></article><article><header><h2><a href=https://ajtl.github.io/post/python_list_and_tuple_are_orderd/>为什么python中的list和tuple是有序的</a></h2><div class=post-meta><div><i class="fa fa-calendar fa-fw"></i>
<time>10 Oct 2019, 19:08</time></div><div><i class="fa fa-folder fa-fw"></i>
<a class=post-taxonomy-topic href=https://ajtl.github.iotopics/python>Python</a></div><div><i class="fa fa-tags fa-fw"></i>
<a class=post-taxonomy-tag href=https://ajtl.github.iotags/python>Python</a>&nbsp;/
<a class=post-taxonomy-tag href=https://ajtl.github.iotags/list>List</a>&nbsp;/
<a class=post-taxonomy-tag href=https://ajtl.github.iotags/tuple>Tuple</a>&nbsp;/
<a class=post-taxonomy-tag href=https://ajtl.github.iotags/dictionary>Dictionary</a></div></div></header><p>What does it mean in Python that tuples and lists are ordered, but dictionaries are not ordered? - Qura
Suppose, we have initialised a list L. And it consists of numbers in it. List looks something like 照例，我们来初始化一个list L并赋一些值在里面。
L=[1, 2, 3, 4, 5] Now, Try doing the following and see the result. 现在 执行下面一些操作并查看结果。将list元素按照索引print到console。
print(L) print(L[0], L[1], L[2], L[3], L[4]) Similarly, let’s initialise a dictionary D 同样的，初始化一个字典 D
D={'Maharashtra': 'Mumbai', 'Rajasthan': 'Jaipur', 'Karnataka': 'Bengaluru'} Likewise, do 执行和list一样的操作，将字典print到console</p><footer><a href=/post/python_list_and_tuple_are_orderd/>Read more<i class="fa fa-angle-double-right fa-fw"></i></a></footer></article><article><header><h2><a href=https://ajtl.github.io/post/hmoebrew_caskupgrade/>解决brew cask软件更新</a></h2><div class=post-meta><div><i class="fa fa-calendar fa-fw"></i>
<time>25 Jun 2019, 10:13</time></div><div><i class="fa fa-folder fa-fw"></i>
<a class=post-taxonomy-topic href=https://ajtl.github.iotopics/homebrew>Homebrew</a></div><div><i class="fa fa-tags fa-fw"></i>
<a class=post-taxonomy-tag href=https://ajtl.github.iotags/homebrew>Homebrew</a>&nbsp;/
<a class=post-taxonomy-tag href=https://ajtl.github.iotags/cask>cask</a>&nbsp;/
<a class=post-taxonomy-tag href=https://ajtl.github.iotags/upgrade>upgrade</a></div></div></header><p>关于Homebrew/Homebrew Cask Homebrew是现如今在Mac平台下较为流行的包管理工具，用以简化 macOS 上的软件安装过程。
项目主页：https://brew.sh GitHub地址：https://github.com/Homebrew
Homebrew Cask是 Homebrew的扩展，借助它可以方便地在 macOS 上安装图形界面程序，即我们常用的各类应用。
但是在实际使用过程中发现cask 更新命令很难达到更新的效果。
brew cask upgrade 最后发现有这样一个方法buo/cask-upgrade
brew cu buo/cask-upgrade这个项目是用来更新通过brew cask安装的每一个过时的APP。 它替代了原生的upgrade命令，提供了更为人性化的细节展示。
GitHub地址：https://github.com/buo/homebrew-cask-upgrade
使用brew cu 安装 brew tap buo/cask-upgrade 使用 更新所有过时APP:
brew cu 更新指定的APP:
brew cu [CASK] 带参更新指定的APP:
brew cu [CASK] [options] 当运行brew cu命令又不带任何参数时，该命令会自动运行brew update获取软件的最新版本。
brew cu 参数 输入
brew help cu 可以获得命令行的文档帮助
Usage: brew cu [CASK] [options] -a, --all Include apps that auto-update in the upgrade.</p><footer><a href=/post/hmoebrew_caskupgrade/>Read more<i class="fa fa-angle-double-right fa-fw"></i></a></footer></article><article><header><h2><a href=https://ajtl.github.io/post/leetcode_longest_palindromic_substring/>LongestPalindromicSubstring/最长回文子串</a></h2><div class=post-meta><div><i class="fa fa-calendar fa-fw"></i>
<time>20 Jun 2019, 17:44</time></div><div><i class="fa fa-folder fa-fw"></i>
<a class=post-taxonomy-topic href=https://ajtl.github.iotopics/leetcode>LeetCode</a></div><div><i class="fa fa-tags fa-fw"></i>
<a class=post-taxonomy-tag href=https://ajtl.github.iotags/leetcode>LeetCode</a>&nbsp;/
<a class=post-taxonomy-tag href=https://ajtl.github.iotags/longestpalindromicsubstring>LongestPalindromicSubstring</a>&nbsp;/
<a class=post-taxonomy-tag href=https://ajtl.github.iotags/c++>C++</a></div></div></header><p>题目 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。
示例 1：
输入: &ldquo;babad&rdquo;
输出: &ldquo;bab&rdquo;
注意: &ldquo;aba&rdquo; 也是一个有效答案。
示例 2：
输入: &ldquo;cbbd&rdquo;
输出: &ldquo;bb&rdquo;
题目链接 CH: https://leetcode-cn.com/problems/longest-palindromic-substring/ EN: https://leetcode.com/problems/longest-palindromic-substring/ 解法一 解法二 总结</p></article><article><header><h2><a href=https://ajtl.github.io/post/leetcode_three_sum/>ThreeSum/三数之和</a></h2><div class=post-meta><div><i class="fa fa-calendar fa-fw"></i>
<time>18 Jun 2019, 10:37</time></div><div><i class="fa fa-folder fa-fw"></i>
<a class=post-taxonomy-topic href=https://ajtl.github.iotopics/leetcode>LeetCode</a></div><div><i class="fa fa-tags fa-fw"></i>
<a class=post-taxonomy-tag href=https://ajtl.github.iotags/leetcode>LeetCode</a>&nbsp;/
<a class=post-taxonomy-tag href=https://ajtl.github.iotags/3sum>3Sum</a>&nbsp;/
<a class=post-taxonomy-tag href=https://ajtl.github.iotags/c++>C++</a></div></div></header><p>题目 给定一个包含n 个整数的数组 nums，判断 nums 中是否存在三个元素a ，b ，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。
注意：答案中不可以包含重复的三元组。
示例:
给定数组 nums = [-1, 0, 1, 2, -1, -4]，
满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]
题目链接 CH: https://leetcode-cn.com/problems/3sum/ EN: https://leetcode.com/problems/3sum/ 解法一 vector&lt;vector&lt;int>> threeSum(vector&lt;int> &nums) { vector&lt;vector&lt;int>> vResult; for (size_t i = 0; i &lt; nums.size()-2; i++) { for (size_t j = i+1; j &lt; nums.</p><footer><a href=/post/leetcode_three_sum/>Read more<i class="fa fa-angle-double-right fa-fw"></i></a></footer></article><article><header><h2><a href=https://ajtl.github.io/post/leetcode_two_sum/>TwoSum/两数之和</a></h2><div class=post-meta><div><i class="fa fa-calendar fa-fw"></i>
<time>17 Jun 2019, 11:08</time></div><div><i class="fa fa-folder fa-fw"></i>
<a class=post-taxonomy-topic href=https://ajtl.github.iotopics/leetcode>LeetCode</a></div><div><i class="fa fa-tags fa-fw"></i>
<a class=post-taxonomy-tag href=https://ajtl.github.iotags/leetcode>LeetCode</a>&nbsp;/
<a class=post-taxonomy-tag href=https://ajtl.github.iotags/twosum>TwoSum</a>&nbsp;/
<a class=post-taxonomy-tag href=https://ajtl.github.iotags/c++>C++</a></div></div></header><p>题目 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。
示例:
给定 nums = [2, 7, 11, 15], target = 9
因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1]
题目链接 CH: https://leetcode-cn.com/problems/two-sum/ EN: https://leetcode.com/problems/two-sum/ 解法一 双重循环，时间复杂度是O(n^2)
vector&lt;int> twoSum(vector&lt;int> &nums, int target) { vector&lt;int> vRes; for (size_t i = 0; i &lt; nums.size() - 1; i++) { for (size_t j = i + 1; j &lt; nums.</p><footer><a href=/post/leetcode_two_sum/>Read more<i class="fa fa-angle-double-right fa-fw"></i></a></footer></article><article><header><h2><a href=https://ajtl.github.io/post/cpp_delete_this/>C++ delete this</a></h2><div class=post-meta><div><i class="fa fa-calendar fa-fw"></i>
<time>01 Jun 2019, 16:54</time></div><div><i class="fa fa-folder fa-fw"></i>
<a class=post-taxonomy-topic href=https://ajtl.github.iotopics/c++>c++</a></div><div><i class="fa fa-tags fa-fw"></i>
<a class=post-taxonomy-tag href=https://ajtl.github.iotags/c++>c++</a>&nbsp;/
<a class=post-taxonomy-tag href=https://ajtl.github.iotags/delete>delete</a></div></div></header><p>C++中delete this的注意事项 你必须100%绝对确保this对象是通过new分配的（不是通过new[]，不是placement new，不是栈上的局部对象，不是全局对象，不是另一个对象的数据成员；仅仅只是通过原始的new运算符）
你必须100%绝对确保调用delete this操作的成员函数是最后调用的成员函数
你必须100%绝对确保在当前函数中delete this后，调用的其他成员函数不会读取this对象。
你必须100%确保再也不会使用this指针。即使你使用this指针和其他指针比较，例如nullptr，打印this指针，转换this指针等等。
delete this语句其实比较危险，在不同的编译器也会有不同的输出结果。最好私有化该类的构造函数，另外提供create函数。</p></article><article><header><h2><a href=https://ajtl.github.io/post/docker_introduction/>Docker 从入门到实践</a></h2><div class=post-meta><div><i class="fa fa-calendar fa-fw"></i>
<time>24 May 2019, 14:28</time></div><div><i class="fa fa-folder fa-fw"></i>
<a class=post-taxonomy-topic href=https://ajtl.github.iotopics/docker>docker</a></div><div><i class="fa fa-tags fa-fw"></i>
<a class=post-taxonomy-tag href=https://ajtl.github.iotags/docker>docker</a></div></div></header><p>update on 20:31 28/5/2019
source site Docker 从入门到实践.mindnote Docker 简介 什么是 Docker 使用Go进行开发实现 基于Linux内核,对进程进行封装隔离 操作系统层面的虚拟化技术 Docker 优势 更高效的利用系统 更快速的启动时间 一致的运行环境 持续交付和部署 更轻松的迁移 更轻松的维护和扩展 基本概念 镜像 Image 一个类root 文件系统 提供运行所需文件及配置参数 不包含任何动态数据 在构建后不会被改变 分层存储，使得镜像的复用、定制更容易 容器 Container 镜像运行的实体 基于镜像 创建存储层 仓库 Repository 存储镜像 一个dock registry 包含多个仓库 一个仓库包含多个镜像 通过&lt;仓库名>:&lt;标签>指定镜像 安装Docker CE 社区版 Stable 6months Test Nightly EE 企业版 配置镜像加速器 使用镜像 获取镜像 docker pull</p><footer><a href=/post/docker_introduction/>Read more<i class="fa fa-angle-double-right fa-fw"></i></a></footer></article><article><header><h2><a href=https://ajtl.github.io/post/hello_world/>Hello World</a></h2><div class=post-meta><div><i class="fa fa-calendar fa-fw"></i>
<time>17 May 2019, 13:59</time></div></div></header><p>Hello World :smile:</p></article></div></div></div><script src=https://ajtl.github.iojs/ui.js></script><script src=https://ajtl.github.iojs/menus.js></script></body></html>